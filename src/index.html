<!DOCTYPE html><html lang="en"><head><title>src/index</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="src/index"><meta name="groc-project-path" content="src/index.ls"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path">src/index.ls</div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><h1 id="the-future-monad">The Future monad</h1>

<p>The <code>Future(a, b)</code> monad represents values that depend on time. This
allows one to model time-based effects explicitly, such that one can
have full knowledge of when they're dealing with delayed computations,
latency, or anything that can not be computed immediately.</p>

<p>A common use for this monad is to replace the usual
Continuation-Passing Style form of programming, in order to be
able to compose and sequence time-dependent effects using the generic
and powerful monadic operations.</p></div></div></div><div class="segment"><div class="code folded"><div class="wrapper marker"><span class="c1">/** </span></div><div class="wrapper"><span class="cm">/** </span>
<span class="cm"> * Copyright (c) 2013 Quildreen Motta</span>
<span class="cm"> *</span>
<span class="cm"> * Permission is hereby granted, free of charge, to any person</span>
<span class="cm"> * obtaining a copy of this software and associated documentation files</span>
<span class="cm"> * (the &quot;Software&quot;), to deal in the Software without restriction,</span>
<span class="cm"> * including without limitation the rights to use, copy, modify, merge,</span>
<span class="cm"> * publish, distribute, sublicense, and/or sell copies of the Software,</span>
<span class="cm"> * and to permit persons to whom the Software is furnished to do so,</span>
<span class="cm"> * subject to the following conditions:</span>
<span class="cm"> *</span>
<span class="cm"> * The above copyright notice and this permission notice shall be</span>
<span class="cm"> * included in all copies or substantial portions of the Software.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span>
<span class="cm"> * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="cm"> * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</span>
<span class="cm"> * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE</span>
<span class="cm"> * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION</span>
<span class="cm"> * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION</span>
<span class="cm"> * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span>
<span class="cm"> */</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="function-memoised-fork">Function: memoised-fork</h2>

<p>A function that memoises the result of a future operation, and updates
the future with the relevant information for the <code>Show</code> and <code>Eq</code>
typeclass implementations.</p>

<ul>
<li>type: ((a) -> Unit), (b) -> Unit)), Future(a, b) -> ((a) -> Unit, (b) -> Unit)</li>
</ul></div></div><div class="code"><div class="wrapper"><span class="nv">memoised-fork = </span><span class="nf">(f, future) -&gt;</span>
  <span class="nv">pending  = </span><span class="p">[]</span>
  <span class="nv">started  = </span><span class="kc">false</span>
  <span class="nv">resolved = </span><span class="kc">false</span>
  <span class="nv">rejected = </span><span class="kc">false</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The fold applies the correct operation to the future's value, if the
future has been resolved. Or we run the operation instead.</p>

<p>For optimisation purposes, we cache the result of the operation, so
if we started an operation before, we mark it as started and push
any subsequent forks into a pending queue that will be invoked once
the original fork returns.</p></div></div><div class="code"><div class="wrapper">  <span class="k">return</span> <span class="nv">fold = </span><span class="nf">(g, h) -&gt;</span>
    <span class="o">|</span> <span class="nx">resolved</span>  <span class="o">=&gt;</span> <span class="nx">h</span> <span class="nx">future</span><span class="p">.</span><span class="nx">value</span>
    <span class="o">|</span> <span class="nx">rejected</span>  <span class="o">=&gt;</span> <span class="nx">g</span> <span class="nx">future</span><span class="p">.</span><span class="nx">value</span>
    <span class="o">|</span> <span class="nx">started</span>   <span class="o">=&gt;</span> <span class="nx">do</span>
                   <span class="nx">pending</span><span class="p">.</span><span class="nx">push</span> <span class="nv">rejected: </span><span class="nx">g</span><span class="p">,</span> <span class="nv">resolved: </span><span class="nx">h</span>
                   <span class="kc">void</span>
    <span class="o">|</span> <span class="nx">otherwise</span> <span class="o">=&gt;</span> <span class="nx">do</span>
                   <span class="nv">started = </span><span class="kc">true</span>
                   <span class="nx">f</span> <span class="nx">do</span>
                     <span class="o">*</span> <span class="nf">(a) -&gt;</span> <span class="nx">do</span>
                              <span class="nx">future</span><span class="p">.</span><span class="nx">is-pending</span>  <span class="o">:=</span> <span class="kc">false</span>
                              <span class="nx">future</span><span class="p">.</span><span class="nx">is-rejected</span> <span class="o">:=</span> <span class="nx">rejected</span> <span class="o">:=</span> <span class="kc">true</span>
                              <span class="nx">future</span><span class="p">.</span><span class="nx">value</span>       <span class="o">:=</span> <span class="nx">a</span>
                              <span class="nx">invoke-pending</span> <span class="s">\rejected</span><span class="p">,</span> <span class="nx">a</span>
                              <span class="nx">g</span> <span class="nx">a</span>
                     <span class="o">*</span> <span class="nf">(b) -&gt;</span> <span class="nx">do</span>
                              <span class="nx">future</span><span class="p">.</span><span class="nx">is-pending</span>  <span class="o">:=</span> <span class="kc">false</span>
                              <span class="nx">future</span><span class="p">.</span><span class="nx">is-resolved</span> <span class="o">:=</span> <span class="nx">resolved</span> <span class="o">:=</span> <span class="kc">true</span>
                              <span class="nx">future</span><span class="p">.</span><span class="nx">value</span>       <span class="o">:=</span> <span class="nx">b</span>
                              <span class="nx">invoke-pending</span> <span class="s">\resolved</span><span class="p">,</span> <span class="nx">b</span>
                              <span class="nx">h</span> <span class="nx">b</span>

  <span class="nx">function</span> <span class="nx">invoke-pending</span><span class="p">(</span><span class="nx">kind</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
    <span class="nv">xs              = </span><span class="nx">pending</span>
    <span class="nx">started</span>        <span class="o">:=</span> <span class="kc">false</span>
    <span class="nx">pending</span><span class="p">.</span><span class="nx">length</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="nx">x</span> <span class="k">in</span> <span class="nx">xs</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">[</span><span class="nx">kind</span><span class="p">]</span> <span class="nx">value</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="function-id">Function: id</h2>

<p>The identity function.</p>

<ul>
<li>type: a -> a</li>
</ul></div></div><div class="code"><div class="wrapper"><span class="nv">id = </span><span class="nf">(a) -&gt;</span> <span class="nx">a</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="excepction-rejectedfutureextractionerror">Excepction: RejectedFutureExtractionError</h2>

<p>Thrown when trying to extract the value of a rejected future.</p></div></div><div class="code"><div class="wrapper"><span class="k">class</span> <span class="nx">RejectedFutureExtractionError</span> <span class="k">extends</span> <span class="nx">TypeError</span>
  <span class="nf">-&gt;</span> <span class="k">super</span> <span class="s">&quot;Can&#39;t extract the value of a rejected future.&quot;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="class-future">Class: Future</h2>

<p>The <code>Future(a, b)</code> monad.</p></div></div><div class="code"><div class="wrapper"><span class="k">class</span> <span class="nx">Future</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="section-constructors">Section: Constructors</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="constructor">Constructor</h4>

<p>Creates a new Future for a long-running computation <code>f</code>.
+ type: ((a -> Unit), (b -> Unit)) -> Promise(a, b)</p></div></div><div class="code"><div class="wrapper">  <span class="nf">(f) -&gt;</span> <span class="vi">@fork = </span><span class="nx">memoised-fork</span> <span class="nx">f</span><span class="p">,</span> <span class="k">this</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="section-predicates">Section: Predicates</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="field-is-pending">Field: is-pending</h4>

<p>True if the Future hasn't been resolved yet.</p>

<ul>
<li>type: Boolean</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="o">is-</span><span class="nv">pending: </span><span class="kc">true</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="field-is-resolved">Field: is-resolved</h4>

<p>True if the Future has been resolved successfully.
+ type: Boolean</p></div></div><div class="code"><div class="wrapper">  <span class="o">is-</span><span class="nv">resolved: </span><span class="kc">false</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="field-is-failure">Field: is-failure</h4>

<p>True if the Future has been rejected — resolved with a failure.
+ type: Boolean</p></div></div><div class="code"><div class="wrapper">  <span class="o">is-</span><span class="nv">rejected: </span><span class="kc">false</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="section-applicative">Section: Applicative</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-of">Function: of</h4>

<p>Constructs a new Future containing the single value <code>b</code>.
<code>b</code> can be any value, including <code>null</code>, <code>undefined</code> or another
<code>Future(a, b)</code> monad.
+ type: b -> Future(a, b)</p></div></div><div class="code"><div class="wrapper">  <span class="vi">@of = </span><span class="nf">(b) -&gt;</span> <span class="k">new</span> <span class="nx">Future</span> <span class="nf">(reject, resolve) -&gt;</span> <span class="nx">resolve</span> <span class="nx">b</span>
  <span class="k">of</span><span class="o">:</span> <span class="nf">(b) -&gt;</span> <span class="nx">Future</span><span class="p">.</span><span class="nx">of</span> <span class="nx">b</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-ap">Function: ap</h4>

<p>Applies the function inside the Future to an applicative.
+ type: (@Future(a, b -> c), f:Applicative) => f(b) -> f(c)</p></div></div><div class="code"><div class="wrapper">  <span class="nv">ap: </span><span class="nf">(b) -&gt;</span> <span class="nx">@chain</span> <span class="nf">(f) -&gt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">map</span> <span class="nx">f</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="section-functor">Section: Functor</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-map">Function: map</h4>

<p>Transforms the successful value of the Future using a regular unary
function.
+ type: (@Future(a, b)) => (b -> c) -> Future(a, c)</p></div></div><div class="code"><div class="wrapper">  <span class="nv">map: </span><span class="nf">(f) -&gt;</span> <span class="nx">@chain</span> <span class="nf">(a) -&gt;</span> <span class="nx">Future</span><span class="p">.</span><span class="nx">of</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">a</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="section-chain">Section: Chain</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-chain">Function: chain</h4>

<p>Transforms the successful value of the Future using a function to a
monad of the same type.
+ type: (@Future(a, b)) => (b -> Future(a, c)) -> Future(a, c)</p></div></div><div class="code"><div class="wrapper">  <span class="nv">chain: </span><span class="nf">(f) -&gt;</span>
    <span class="k">new</span> <span class="nx">Future</span> <span class="nf">(reject, resolve) ~&gt;</span> <span class="nx">@fork</span> <span class="nx">do</span>
                                          <span class="o">*</span> <span class="nf">(a) -&gt;</span> <span class="nx">reject</span> <span class="nx">a</span>
                                          <span class="o">*</span> <span class="nf">(b) -&gt;</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">b</span><span class="p">).</span><span class="nx">fork</span> <span class="nx">reject</span><span class="p">,</span> <span class="nx">resolve</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="section-show">Section: Show</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-to-string">Function: to-string</h4>

<p>Returns a textual representation of the Future monad.</p>

<ul>
<li>type: (@Future(a, b)) => Unit -> String</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="k">to</span><span class="o">-</span><span class="nv">string: </span><span class="nf">-&gt;</span>
    <span class="o">|</span> <span class="nx">@</span><span class="o">is-</span><span class="nx">pending</span>  <span class="o">=&gt;</span> <span class="s">&quot;Future.Pending&quot;</span>
    <span class="o">|</span> <span class="nx">@</span><span class="o">is-</span><span class="nx">resolved</span> <span class="o">=&gt;</span> <span class="s">&quot;Future.Resolved(</span><span class="si">#{</span><span class="nx">@value</span><span class="si">}</span><span class="s">)&quot;</span>
    <span class="o">|</span> <span class="nx">@</span><span class="o">is-</span><span class="nx">rejected</span> <span class="o">=&gt;</span> <span class="s">&quot;Future.Rejected(</span><span class="si">#{</span><span class="nx">@value</span><span class="si">}</span><span class="s">)&quot;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="section-eq">Section: Eq</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-is-equal">Function: is-equal</h4>

<p>Tests if an Future monad is equal to another Future monad.</p>

<p>Equality with pending futures is only decidable if the computation
of both futures can be resolved synchronously. Otherwise this
function will return false.
+ type: (@Future(a, b)) => Future(a, b) -> Boolean</p></div></div><div class="code"><div class="wrapper">  <span class="o">is-</span><span class="nv">equal: </span><span class="nf">(a) -&gt;</span> <span class="nb">Boolean</span> <span class="k">switch</span>
    <span class="o">|</span> <span class="nx">@</span><span class="o">is-</span><span class="nx">resolved</span> <span class="o">=&gt;</span> <span class="nx">a</span><span class="p">.</span><span class="nx">is-resolved</span> <span class="o">and</span> <span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">value</span> <span class="o">is</span> <span class="nx">@value</span><span class="p">)</span>
    <span class="o">|</span> <span class="nx">@</span><span class="o">is-</span><span class="nx">rejected</span> <span class="o">=&gt;</span> <span class="nx">a</span><span class="p">.</span><span class="nx">is-rejected</span> <span class="o">and</span> <span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">value</span> <span class="o">is</span> <span class="nx">@value</span><span class="p">)</span>
    <span class="o">|</span> <span class="nx">@</span><span class="o">is-</span><span class="nx">pending</span>  <span class="o">=&gt;</span> <span class="nx">@fork</span> <span class="nx">do</span>
                            <span class="o">*</span> <span class="nf">(e) -&gt;</span> <span class="nx">a</span><span class="p">.</span><span class="nx">fork</span> <span class="nx">do</span>
                                            <span class="o">*</span> <span class="nf">(e2) -&gt;</span> <span class="nx">e</span> <span class="o">is</span> <span class="nx">e2</span>
                                            <span class="o">*</span> <span class="nf">(_)  -&gt;</span> <span class="kc">false</span>
                            <span class="o">*</span> <span class="nf">(s) -&gt;</span> <span class="nx">a</span><span class="p">.</span><span class="nx">fork</span> <span class="nx">do</span>
                                            <span class="o">*</span> <span class="nf">(_)  -&gt;</span> <span class="kc">false</span>
                                            <span class="o">*</span> <span class="nf">(s2) -&gt;</span> <span class="nx">s</span> <span class="o">is</span> <span class="nx">s2</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="section-extracting-and-recovering">Section: Extracting and Recovering</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-or-else">Function: or-else</h4>

<p>Transforms a failure value into a new Future monad. Does nothing if
the monad contains a successful value.
+ type: (@Future(a, b)) => (a -> Future(c, b)) -> Future(c, b)</p></div></div><div class="code"><div class="wrapper">  <span class="o">or-</span><span class="k">else</span><span class="o">:</span> <span class="nf">(f) -&gt;</span>
    <span class="k">new</span> <span class="nx">Future</span> <span class="nf">(reject, resolve) ~&gt;</span> <span class="nx">@fork</span> <span class="nx">do</span>
                                          <span class="o">*</span> <span class="nf">(a) -&gt;</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">a</span><span class="p">).</span><span class="nx">fork</span> <span class="nx">reject</span><span class="p">,</span> <span class="nx">resolve</span>
                                          <span class="o">*</span> <span class="nf">(b) -&gt;</span> <span class="nx">resolve</span> <span class="nx">b</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="section-folds-and-extended-transformations">Section: Folds and Extended Transformations</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-fold">Function: fold</h4>

<p>Catamorphism. Takes two functions, applies the leftmost one to the
failure value and the rightmost one to the successful value,
depending on which one is present.
+ type: (@Future(a, b)) => (a -> c) -> (b -> c) -> Future(d, c)</p></div></div><div class="code"><div class="wrapper">  <span class="nv">fold: </span><span class="nf">(f, g) --&gt;</span> <span class="k">new</span> <span class="nx">Future</span> <span class="nf">(reject, resolve) ~&gt;</span> <span class="nx">@fork</span> <span class="nx">do</span>
                                                         <span class="o">*</span> <span class="nf">(a) -&gt;</span> <span class="nx">resolve</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">a</span><span class="p">)</span>
                                                         <span class="o">*</span> <span class="nf">(b) -&gt;</span> <span class="nx">resolve</span> <span class="p">(</span><span class="nx">g</span> <span class="nx">b</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-swap">Function: swap</h4>

<p>Swaps the disjunction values.</p>

<ul>
<li>type: (@Future(a, b)) => Unit -> Future(b, a)</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="nv">swap: </span><span class="nf">-&gt;</span> <span class="k">new</span> <span class="nx">Future</span> <span class="nf">(reject, resolve) ~&gt;</span> <span class="nx">@fork</span> <span class="nx">do</span>
                                                 <span class="o">*</span> <span class="nf">(a) -&gt;</span> <span class="nx">resolve</span> <span class="nx">a</span>
                                                 <span class="o">*</span> <span class="nf">(b) -&gt;</span> <span class="nx">reject</span> <span class="nx">b</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-bimap">Function: bimap</h4>

<p>Maps both sides of the disjunction.
+ type: (@Future(a, b)) => (a -> c) -> (b -> d) -> Future(c, d)</p></div></div><div class="code"><div class="wrapper">  <span class="nv">bimap: </span><span class="nf">(f, g) --&gt;</span> <span class="k">new</span> <span class="nx">Future</span> <span class="nf">(reject, resolve) ~&gt;</span> <span class="nx">@fork</span> <span class="nx">do</span>
                                                          <span class="o">*</span> <span class="nf">(a) -&gt;</span> <span class="nx">reject</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">a</span><span class="p">)</span>
                                                          <span class="o">*</span> <span class="nf">(b) -&gt;</span> <span class="nx">resolve</span> <span class="p">(</span><span class="nx">g</span> <span class="nx">b</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-rejected-map">Function: rejected-map</h4>

<p>Maps the left side of the disjunction (failure).</p>

<ul>
<li>type: (@Future(a, b)) => (a -> c) -> Future(c, b)</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="nv">rejected-map: </span><span class="nf">(f) -&gt;</span> <span class="k">new</span> <span class="nx">Future</span> <span class="nf">(reject, resolve) ~&gt;</span> <span class="nx">@fork</span> <span class="nx">do</span>
                                                             <span class="o">*</span> <span class="nf">(a) -&gt;</span> <span class="nx">reject</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">a</span><span class="p">)</span>
                                                             <span class="o">*</span> <span class="nf">(b) -&gt;</span> <span class="nx">resolve</span> <span class="nx">b</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="exports">Exports</h2></div></div></div><div class="segment"><div class="code"><div class="wrapper"><span class="nv">module.exports = </span><span class="nx">Future</span></div></div></div></div></body></html>